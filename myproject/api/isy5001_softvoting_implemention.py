# -*- coding: utf-8 -*-
"""ISY5001_softvoting_Implemention.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16WIBk2DEoD6HZJOUpB0HZ5jPGBZEG3Ze
"""





import librosa
import numpy as np
import torch
import torch.nn.functional as F
import io
import joblib
import torch
import torch.nn as nn
import torch.optim as optim
import os


def load_sklearn_model(model_path):
    model = joblib.load(model_path)
    return model


def extract_features(audio_data, sr):
    mfccs = librosa.feature.mfcc(y=audio_data, sr=sr, n_mfcc=13)
    mfccs_mean = np.mean(mfccs.T, axis=0)
    return mfccs_mean

# def predict(model, features):

#     if isinstance(model, torch.nn.Module):
#         features_tensor = torch.tensor(features, dtype=torch.float32).unsqueeze(0).to(device)
#         with torch.no_grad():
#             output = model(features_tensor)
#             probabilities = F.softmax(output, dim=1).numpy().flatten()
#     else:
#         features = features.reshape(1, -1)
#         probabilities = model.predict_proba(features)[0]

#     return probabilities

def predict(model, features):
    if isinstance(model, torch.nn.Module):
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        features_tensor = torch.tensor(features, dtype=torch.float32).unsqueeze(0).to(device)  # 使用之前定义的 device
        with torch.no_grad():
            output = model(features_tensor)
            probabilities = F.softmax(output, dim=1).cpu().numpy().flatten()  # 移动到 CPU 后转换为 NumPy
    else:
        features = features.reshape(1, -1)
        probabilities = model.predict_proba(features)[0]

    return probabilities


def soft_voting(models, features):
    total_probabilities = None
    num_models = len(models)

    for model in models:
        probabilities = predict(model, features)
        if total_probabilities is None:
            total_probabilities = probabilities
        else:
            total_probabilities += probabilities

    avg_probabilities = total_probabilities / num_models
    predicted_label = np.argmax(avg_probabilities)
    return avg_probabilities, predicted_label





# Define the DNN model
class DNN(nn.Module):
    def __init__(self, input_size):
        super(DNN, self).__init__()
        self.fc1 = nn.Linear(input_size, 128)
        self.relu1 = nn.ReLU()
        self.fc2 = nn.Linear(128, 64)
        self.relu2 = nn.ReLU()
        self.fc3 = nn.Linear(64, 2)  # Output layer with 2 classes (truth/deception)


    def forward(self, x):
        x = self.fc1(x)
        x = self.relu1(x)
        x = self.fc2(x)
        x = self.relu2(x)
        x = self.fc3(x)
        return x

def load_model(model_path):
    """Loads a PyTorch model from the specified path.

    Args:
        model_path (str): The path to the saved model file.

    Returns:
        nn.Module: The loaded PyTorch model.
    """

    # Create an instance of your DNN model
    model = DNN(input_size=13) # Replace 193 with the actual input size of your model

    # Load the state dictionary into the model
    state_dict = torch.load(model_path, map_location=torch.device('cpu'),weights_only=False)
    model.load_state_dict(state_dict)

    # Set the model to evaluation mode
    model.eval()

    return model


def soft_voting(models, features):
    total_probabilities = None
    num_models = len(models)

    for model in models:
        probabilities = predict(model, features)
        if total_probabilities is None:
            total_probabilities = probabilities
        else:
            total_probabilities += probabilities

    avg_probabilities = total_probabilities / num_models
    predicted_label = np.argmax(avg_probabilities)
    return avg_probabilities, predicted_label




if __name__=='__main__':

    

    # 定义音频文件路径
    audio_path = r"C:\Users\123\Desktop\project5001\AN_WILTY_EP15_lie10.wav"  # 替换为实际路径

    # 确保文件存在
    if os.path.exists(audio_path):
        # 使用 librosa 加载音频文件
        audio_data, sr = librosa.load(audio_path, sr=None)
        print("音频数据加载成功！")
    else:
        print("文件不存在，请检查路径。")


    features = extract_features(audio_data, sr)

    rf_model_path = r'D:\project\project5001-backend-master\myproject\detection\rf_classifier.joblib'
    knn_model_path = r'D:\project\project5001-backend-master\myproject\detection\knn_classifier.joblib'
    dnn_model_path = r'D:\project\project5001-backend-master\myproject\detection\dnn_model (1).pth'
    svm_model_path = r'D:\project\project5001-backend-master\myproject\detection\best_svm_model (2).joblib'
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    rf_model = load_sklearn_model(rf_model_path)
    knn_model = load_sklearn_model(knn_model_path)
    svm_model = load_sklearn_model(svm_model_path)
    dnn_model = load_model(dnn_model_path)
    dnn_model.to(device)
    # if hasattr(svm_model, 'predict_proba'):
    #     probabilities = svm_model.predict_proba(features)
    # else:
    #     print("模型不支持概率预测，请确保在训练时启用了 probability=True。")

    models = [rf_model, knn_model, svm_model, dnn_model]
    avg_probabilities, predicted_label = soft_voting(models, features)
    print(f"Predicted Label: {predicted_label}")
    print(f"Average Probabilities: {avg_probabilities}")
    labels = ['deception', 'true']
    deception_probability = avg_probabilities[0]
    print(f"Deception Probability: {deception_probability}")